func mesh3 genmesh(real e)
{
    assert(e > 0);
    assert(e <= 0.35);

    real h = 0.4; // 0.4m
    real l = 1.7; // 1.7m
    real r = 0.35; // 0.35m
    real pz = 0.5;

    int gamma0 = 1;
    int gammaD = 2;
    int gammaN = 3;

    real Y0 = h + r-e; 
    real L0 = l - 2*r;
    real R0 = r - e;

    assert((h + r-e) > 0);
    assert((r - e) > 0);

    border C01(t=-1, 1){x=L0*t/2.; y=0; label=gamma0;};
    border C02(t=1, -1){x=L0*t/2.; y=e; label=gammaN;};
    border C03(t=pi/2., 0){x=L0/2. + R0*cos(t); y=-R0 + R0*sin(t); label=gamma0;};
    border C05(t=0, pi/2.){x=L0/2. + r*cos(t); y=-R0 + r*sin(t); label=gamma0;};
    border C04(t=pi, pi/2.){x=-L0/2. + R0*cos(t); y=-R0 + R0*sin(t); label=gamma0;};
    border C06(t=pi/2., pi){x=-L0/2. + r*cos(t); y=-R0 + r*sin(t); label=gamma0;};
    border C07(t=0, 1){x=l/2-e; y=-R0-t*h; label=gamma0;};
    border C08(t=0, 1){x=l/2-e + t*e; y=-R0-h; label=gammaD;};
    border C09(t=0, 1){x=l/2; y=-R0-h+t*h; label=gamma0;};
    border C10(t=1, 0){x=-l/2+e; y=-R0-t*h; label=gamma0;};
    border C11(t=1, 0){x=-l/2+e - t*e; y=-R0-h; label=gammaD;};
    border C12(t=1, 0){x=-l/2; y=-R0-h+t*h; label=gamma0;};

    int n = 10;
    int nbvx = 1000;
    int nz = 10;
    macro CUMPOSITEBORDER(t) (C01(t) + C02(t) + C03(t) + C04(t) + C05(t) + C06(t) + C07(t) + C08(t) + C09(t) + C10(t) + C11(t) + C12(t))//
    mesh Th0 = buildmesh(CUMPOSITEBORDER(n));

    Th0 = adaptmesh(Th0, 1./20., IsMetric=1, nbvx=nbvx);
    int[int] lup = [0, gamma0];
    mesh3 Th1 = buildlayers(
        Th0,
        nz,
        zbound=[0, pz],
        labelup=lup,
        labeldown=lup
    );
    mesh3 Th = movemesh3(
        Th1,
        transfo=[x, z, y],
        orientation=-1
    );
    return Th;
};

func real deflection(mesh3 &Th)
{
    int gamma0 = 1;
    int gammaD = 2;
    int gammaN = 3;

    real rho = 7800; // 7800 kg/m3
    real gz = -9.81; 
    real t0z = -5 * 10^8; //
    real fv = rho*gz;

    real E = 2.1 * 10^11;
    real nu = 0.3;
    real mu = E/(2*(1+nu));
    real lambda = E*nu/((1+nu)*(1-2*nu));

    fespace Vh(Th, P2);
    Vh ux, uy, uz;
    Vh vx, vy, vz;

    real sq2=sqrt(2.);
    macro epsilon(u1,u2,u3) [dx(u1), dy(u2), dz(u3), (dy(u1) + dx(u2))/sq2, (dz(u1) + dx(u3))/sq2, (dy(u3) + dz(u2))/sq2] //
    macro div(u1, u2, u3) (dx(u1) + dy(u2) + dz(u3)) //

    problem Lame([ux, uy, uz], [vx, vy, vz])
        = int3d(Th)(
            lambda*div(ux, uy, uz)*div(vx, vy, vz) + 2.*mu*(epsilon(ux, uy, uz)' * epsilon(vx, vy, vz))
        ) - int3d(Th)(
            fv*vz
        ) - int2d(Th, gammaN)(
            t0z*vz
        )
        + on(gammaD, ux=0, uy=0, uz=0); // dirichlet

    Lame;
    real d = abs(uz(0, 0, 0));
    return d;
}